<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Modified Dijkstra</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .hidden-panel { display: none !important; }
        .panel-container {
            display: flex;
            flex-direction: column;
        }
        .node-label { pointer-events: none; }
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #1f2937; }
        ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 10px; }
        /* Removed CSS transitions for D3 controlled elements to allow fast updates */
        .node-circle { } 
        .link-line { }
        .bg-graph { background-color: #111827; }
        /* For PQ animations */
        .pq-item {
            transition: opacity 0.4s ease-out, transform 0.4s ease-out, background-color 0.4s, border-color 0.4s;
        }
    </style>
    <!-- Dependencies -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="bg-gray-900 text-gray-100 font-sans overflow-hidden">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useCallback, useRef, useEffect, useLayoutEffect } = React;
        const MOD = 1000000007;

        // --- From lib/dijkstra.ts ---
        let pqKeyCounter = 0;
        function* dijkstraWidestPath(graph, s, t) {
            const adj = new Map();
            for (const edge of graph.edges) {
                const u = typeof edge.source === 'object' ? edge.source.id : edge.source;
                const v = typeof edge.target === 'object' ? edge.target.id : edge.target;
                if (!adj.has(u)) adj.set(u, []);
                if (!adj.has(v)) adj.set(v, []);
                adj.get(u).push({ v: v, w: edge.weight });
                adj.get(v).push({ v: u, w: edge.weight });
            }

            const height = {};
            const before = {};
            graph.nodes.forEach(n => {
                height[n.id] = 0;
                before[n.id] = null;
            });

            height[s] = MOD;
            pqKeyCounter = 0;
            let pq = [{ id: s, h: MOD, key: pqKeyCounter++ }];
            const pqSort = (a, b) => {
                if (b.h !== a.h) return b.h - a.h;
                return a.id - b.id;
            };

            let currentLog = `Init: Node ${s} capacity = ∞`;
            yield {
                phase: 'init', heights: { ...height }, before: { ...before }, pq: [...pq], u: null,
                log: currentLog
            };

            while (pq.length > 0) {
                pq.sort(pqSort);
                const top = pq[0];
                const u = top.id;
                const curr_h = top.h;
                const poppedKey = top.key;
                
                // Keep the previous log during the "pre-pop" animation phase to reduce noise
                yield {
                    phase: 'pre-pop', heights: { ...height }, before: { ...before }, pq: [...pq], u: u, poppedKey: poppedKey,
                    log: currentLog
                };
                
                pq.shift();

                if (curr_h < height[u]) {
                    currentLog = `Skip ${u}: Stale entry (${curr_h} < ${height[u]})`;
                    yield {
                        phase: 'skip-highlight', heights: { ...height }, before: { ...before }, pq: [...pq], u: u,
                        log: currentLog
                    };
                    
                    currentLog = `Skip ${u}: A better path already exists`;
                    yield {
                        phase: 'skip', heights: { ...height }, before: { ...before }, pq: [...pq], u: u,
                        log: currentLog
                    };
                    continue;
                }

                currentLog = `Pop ${u} (cap=${curr_h === MOD ? '∞' : curr_h})`;
                yield {
                    phase: 'pop', heights: { ...height }, before: { ...before }, pq: [...pq], u: u,
                    log: currentLog
                };

                if (u === t) {
                    currentLog = `Destination ${t} found. Path finalized.`;
                    yield {
                        phase: 'check-edge', heights: { ...height }, before: { ...before }, pq: [...pq], u: u,
                        log: currentLog
                    };
                    continue;
                }

                const neighbors = adj.get(u) || [];
                for (const edge of neighbors) {
                    const v = edge.v;
                    const w = edge.w;
                    const new_h = Math.min(curr_h, w);

                    currentLog = `Check ${u}→${v}: Min(${curr_h === MOD ? '∞' : curr_h}, ${w}) = ${new_h}`;
                    yield {
                        phase: 'check-edge', heights: { ...height }, before: { ...before }, pq: [...pq], u: u, v: v, edgeWeight: w,
                        log: currentLog
                    };

                    if (new_h > height[v]) {
                        height[v] = new_h;
                        before[v] = u;
                        
                        currentLog = `Push ${v}: New capacity ${new_h}`;

                        pq.push({ id: v, h: new_h, key: pqKeyCounter++ });
                        yield {
                            phase: 'relax-pushed', heights: { ...height }, before: { ...before }, pq: [...pq], u: u, v: v,
                            log: currentLog
                        };

                        pq.sort(pqSort);
                        yield {
                            phase: 'relax-sorted', heights: { ...height }, before: { ...before }, pq: [...pq], u: u, v: v,
                            log: currentLog
                        };
                        
                        yield {
                           phase: 'post-sort-wait', heights: { ...height }, before: { ...before }, pq: [...pq], u: u, v: v,
                           log: currentLog 
                        }

                    } else {
                        currentLog = `No capacity update for ${v}`;
                        yield {
                            phase: 'no-relax-highlight', heights: { ...height }, before: { ...before }, pq: [...pq], u: u, v: v,
                            log: currentLog
                        };
                         yield {
                            phase: 'no-relax', heights: { ...height }, before: { ...before }, pq: [...pq], u: u, v: v,
                            log: currentLog
                        };
                    }
                }
            }

            const path = [];
            if (height[t] > 0) {
                let curr = t;
                while (curr !== null) {
                    path.unshift(curr);
                    if (curr === s) break;
                    curr = before[curr];
                    if (curr === undefined) { path.length = 0; break; }
                }
                if (path.length > 0 && path[0] !== s) { path.length = 0; }
            }

            return {
                phase: 'finished', heights: { ...height }, before: { ...before }, pq: [], u: null, path: path,
                log: `Done. Capacity: ${height[t] > 0 ? height[t] : 'N/A'}. Path: ${path.length > 0 ? path.join('→') : 'Not found'}`
            };
        }

        // --- From components/GraphVisualizer.tsx ---
        const GraphVisualizer = ({ graphData, stepState, duration }) => {
            const svgRef = useRef(null);
            const containerRef = useRef(null);
            const simulationRef = useRef(null);

            const updateDimensions = () => {
                if (!containerRef.current || !svgRef.current) return;
                const { width, height } = containerRef.current.getBoundingClientRect();
                d3.select(svgRef.current).attr('width', width).attr('height', height);
                if (simulationRef.current) {
                    simulationRef.current.force("center", d3.forceCenter(width / 2, height / 2));
                    simulationRef.current.alpha(0.3).restart();
                }
            };

            // Use ResizeObserver to automatically handle layout changes (e.g. sidebar appearing)
            useEffect(() => {
                if (!containerRef.current) return;
                updateDimensions();
                
                const resizeObserver = new ResizeObserver(() => {
                    updateDimensions();
                });
                
                resizeObserver.observe(containerRef.current);
                return () => resizeObserver.disconnect();
            }, []);

            useEffect(() => {
                if (!svgRef.current || !containerRef.current) return;
                
                const svg = d3.select(svgRef.current);

                if (!graphData) {
                    if (simulationRef.current) simulationRef.current.stop();
                    simulationRef.current = null;
                    svg.selectAll("*").remove();
                    return;
                }

                const { width, height } = containerRef.current.getBoundingClientRect();
                const nodes = JSON.parse(JSON.stringify(graphData.nodes));
                const edges = JSON.parse(JSON.stringify(graphData.edges));

                if (simulationRef.current) simulationRef.current.stop();
                
                const simulation = d3.forceSimulation(nodes)
                    .force("link", d3.forceLink(edges).id((d) => d.id).distance(150))
                    .force("charge", d3.forceManyBody().strength(-800))
                    .force("center", d3.forceCenter(width / 2, height / 2));
                
                simulationRef.current = simulation;
                svg.selectAll("*").remove();

                const link = svg.append("g").selectAll("line").data(edges).join("line")
                    .attr("class", "link link-line")
                    .attr("stroke", "#374151").attr("stroke-opacity", 0.6)
                    .attr("stroke-width", (d) => Math.max(2, Math.sqrt(d.weight / 2)));

                const edgeLabels = svg.append("g").selectAll("text").data(edges).join("text")
                    .attr("class", "text-xs fill-gray-500 font-bold pointer-events-none")
                    .attr("text-anchor", "middle")
                    .text((d) => d.weight);

                const node = svg.append("g").selectAll("circle").data(nodes).join("circle")
                    .attr("class", "node node-circle")
                    .attr("r", 20).attr("fill", "#1f2937")
                    .attr("stroke", "#4b5563").attr("stroke-width", 2)
                    .call(drag(simulation));

                const nodeLabels = svg.append("g").selectAll("text").data(nodes).join("text")
                    .attr("class", "node-label text-sm fill-white font-bold")
                    .attr("text-anchor", "middle").attr("dy", ".35em")
                    .text((d) => d.id);

                const nodeHeightLabels = svg.append("g").selectAll("text").data(nodes).join("text")
                    .attr("class", "node-height-text font-mono")
                    .attr("text-anchor", "middle")
                    .attr("dy", "3.2em");

                simulation.on("tick", () => {
                    link.attr("x1", (d) => d.source.x).attr("y1", (d) => d.source.y)
                        .attr("x2", (d) => d.target.x).attr("y2", (d) => d.target.y);
                    edgeLabels.attr("x", (d) => (d.source.x + d.target.x) / 2)
                              .attr("y", (d) => (d.source.y + d.target.y) / 2);
                    node.attr("cx", (d) => d.x).attr("cy", (d) => d.y);
                    nodeLabels.attr("x", (d) => d.x).attr("y", (d) => d.y);
                    nodeHeightLabels.attr("x", (d) => d.x).attr("y", (d) => d.y);
                });
                
            }, [graphData]);

            useEffect(() => {
                if (!stepState) return;

                const svg = d3.select(svgRef.current);
                // Use dynamic duration passed from parent
                const animDuration = duration || 400; 
                
                const COLOR_DEFAULT = "#374151", COLOR_U_NODE = "#facc15", COLOR_V_NODE = "#ef4444";
                const COLOR_ACTIVE_EDGE = "#facc15", COLOR_HEIGHT_TEXT = "#3b82f6", COLOR_PATH = "#10b981";
                const COLOR_NO_RELAX = "#8b5cf6", COLOR_TREE_EDGE = "#60a5fa";

                svg.selectAll("circle.node")
                    .transition().duration(animDuration)
                    .attr("fill", (d) => {
                        if ((stepState.phase === 'no-relax-highlight' && d.id === stepState.v) || (stepState.phase === 'skip-highlight' && d.id === stepState.u)) return COLOR_NO_RELAX;
                        if (stepState.phase === 'finished' && stepState.path?.includes(d.id)) return COLOR_PATH;
                        if (d.id === stepState.u) return COLOR_U_NODE;
                        if (d.id === stepState.v) return COLOR_V_NODE;
                        if (stepState.heights[d.id] > 0) return "#1f2937";
                        return COLOR_DEFAULT;
                    })
                    .attr("stroke", (d) => {
                        if ((stepState.phase === 'no-relax-highlight' && d.id === stepState.v) || (stepState.phase === 'skip-highlight' && d.id === stepState.u)) return "#fff";
                        if (stepState.phase === 'finished' && stepState.path?.includes(d.id)) return "#fff";
                        if (d.id === stepState.u || d.id === stepState.v) return "#fff";
                        return "#4b5563";
                    })
                    .attr("r", (d) => (d.id === stepState.u) ? 32 : (d.id === stepState.v) ? 28 : 20);

                svg.selectAll("line.link")
                    .transition().duration(animDuration)
                    .attr("stroke", (d) => {
                        const u = d.source.id, v = d.target.id;
                        if (stepState.phase === 'finished' && stepState.path) {
                           const idxU = stepState.path.indexOf(u), idxV = stepState.path.indexOf(v);
                           if (idxU > -1 && idxV > -1 && Math.abs(idxU - idxV) === 1) return COLOR_PATH;
                        }
                        if ((u === stepState.u && v === stepState.v) || (v === stepState.u && u === stepState.v)) return COLOR_ACTIVE_EDGE;
                        if (stepState.before && (stepState.before[u] === v || stepState.before[v] === u)) return COLOR_TREE_EDGE;
                        return "#374151";
                    })
                    .attr("stroke-width", (d) => {
                        const u = d.source.id, v = d.target.id;
                         if (stepState.phase === 'finished' && stepState.path) {
                           const idxU = stepState.path.indexOf(u), idxV = stepState.path.indexOf(v);
                           if (idxU > -1 && idxV > -1 && Math.abs(idxU - idxV) === 1) return 8;
                        }
                        if ((u === stepState.u && v === stepState.v) || (v === stepState.u && u === stepState.v)) return 8;
                        if (stepState.before && (stepState.before[u] === v || stepState.before[v] === u)) return 6;
                        return Math.max(2, Math.sqrt(d.weight / 2));
                    });

                svg.selectAll(".node-height-text")
                    .transition().duration(animDuration)
                    .attr("fill", COLOR_HEIGHT_TEXT)
                    .attr("font-size", "18px").attr("font-weight", "900")
                    .text((d) => {
                        const h = stepState.heights[d.id];
                        if (h === undefined || h === 0) return "";
                        return h === MOD ? "∞" : h;
                    });
            }, [stepState, duration]);

            const drag = (simulation) => {
                return d3.drag()
                    .on("start", (event, d) => { if (!event.active) simulation.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; })
                    .on("drag", (event, d) => { d.fx = event.x; d.fy = event.y; })
                    .on("end", (event, d) => { if (!event.active) simulation.alphaTarget(0); d.fx = null; d.fy = null; });
            }

            return <div ref={containerRef} className="w-full h-full"><svg ref={svgRef} className="absolute top-0 left-0 w-full h-full"></svg></div>;
        };

        // --- From App.tsx ---
        function App() {
            const defaultEdges = `1 2 20\n1 3 15\n1 4 10\n2 3 8\n2 5 12\n3 4 5\n3 5 10\n4 5 7`;
            const [edgesInput, setEdgesInput] = useState(defaultEdges);
            const [startNode, setStartNode] = useState('1');
            const [targetNode, setTargetNode] = useState('5');
            const [errorMessage, setErrorMessage] = useState('');
            const [graphData, setGraphData] = useState(null);
            const [stepState, setStepState] = useState(null);
            const [isRunning, setIsRunning] = useState(false);
            const [isPaused, setIsPaused] = useState(false);
            const [visualizationSpeed, setVisualizationSpeed] = useState(1550);
            const [startTriggered, setStartTriggered] = useState(false);
            const algorithmRunner = useRef(null);
            const runnerTimeout = useRef(null);
            const pqContainerRef = useRef(null);
            const itemPositionsCache = useRef(new Map());

            // Calculate timing derived values
            const baseDelay = 2050 - visualizationSpeed;
            // Cap animation duration: at max speed (50ms base), duration is ~40ms. At slow speed, max 400ms.
            const currentDuration = Math.min(400, Math.max(40, baseDelay * 0.8));

            const pqState = JSON.stringify(stepState?.pq.map(i => i.key) || []);

            useLayoutEffect(() => {
                if (!pqContainerRef.current) return;

                const newPositions = new Map();
                const children = Array.from(pqContainerRef.current.children);
                for (const child of children) {
                    const key = child.dataset.key;
                    if (key) newPositions.set(key, child.getBoundingClientRect());
                }

                for (const child of children) {
                    const key = child.dataset.key;
                    if (!key) continue;

                    const oldBox = itemPositionsCache.current.get(key);
                    const newBox = newPositions.get(key);

                    if (!oldBox && newBox) { // New item: animate in
                        child.style.opacity = '0';
                        child.style.transform = 'translateX(30px) scale(0.9)';
                        requestAnimationFrame(() => {
                            child.style.opacity = '1';
                            child.style.transform = '';
                        });
                    } else if (oldBox && newBox) { // Existing item: animate move (FLIP)
                        const dy = oldBox.top - newBox.top;
                        if (Math.abs(dy) > 1) {
                            requestAnimationFrame(() => {
                                child.style.transform = `translateY(${dy}px)`;
                                child.style.transition = 'transform 0s';
                                requestAnimationFrame(() => {
                                    child.style.transform = '';
                                    child.style.transition = ''; // Revert to class transition
                                });
                            });
                        }
                    }
                }
                
                itemPositionsCache.current = newPositions;
            }, [pqState]);

            const parseGraphData = useCallback(() => {
                setErrorMessage('');
                try {
                    const lines = edgesInput.split('\n').filter(line => line.trim() !== '');
                    if (lines.length === 0) throw new Error("Edge data is empty.");

                    const allNodeIds = new Set();
                    const edgesRaw = lines.map((line, i) => {
                        const parts = line.split(' ').map(Number);
                        if (parts.length !== 3 || parts.some(isNaN)) throw new Error(`Invalid edge format on line ${i + 1}`);
                        const [u, v, w] = parts;
                        allNodeIds.add(u); allNodeIds.add(v);
                        return { source: u, target: v, weight: w };
                    });

                    if (allNodeIds.size === 0) throw new Error("No valid nodes found.");
                    const nodes = Array.from(allNodeIds).map(id => ({ id }));
                    const startNodeNum = parseInt(startNode, 10), targetNodeNum = parseInt(targetNode, 10);
                    if (!allNodeIds.has(startNodeNum) || !allNodeIds.has(targetNodeNum)) throw new Error("Start/Target node not in graph.");

                    setGraphData({ nodes, edges: edgesRaw });
                    return true;
                } catch (e) {
                    setErrorMessage(e.message);
                    setGraphData(null);
                    return false;
                }
            }, [edgesInput, startNode, targetNode]);
            
            const resetState = () => {
                if (runnerTimeout.current) clearTimeout(runnerTimeout.current);
                algorithmRunner.current = null;
                setIsRunning(false); setIsPaused(false); setStepState(null); setGraphData(null);
                setStartTriggered(false);
            }

            const runStep = useCallback(() => {
                if (!algorithmRunner.current || isPaused) return;
                try {
                    const { value, done } = algorithmRunner.current.next();
                    if (done) {
                        setIsRunning(false);
                        if (value) setStepState(value);
                        return;
                    }
                    setStepState(value);
                    
                    const base = 2050 - visualizationSpeed;
                    const duration = Math.min(400, Math.max(40, base * 0.8));
                    
                    // Default delay is based on speed
                    let delay = base;

                    // Dynamically scale waits for specific phases
                    // For example, when fast (base=50, dur=40), 'check-edge' waits max(50, 40*1.5=60) = 60ms
                    // When slow (base=1000, dur=400), 'check-edge' waits max(1000, 400*1.5=600) = 1000ms
                    
                    if (['check-edge', 'pop', 'relax-pushed', 'no-relax-highlight', 'skip-highlight'].includes(value.phase)) {
                        delay = Math.max(delay, duration + 20); // Small buffer
                    }

                    if (value.phase === 'check-edge') {
                        delay = Math.max(delay, duration * 1.5); 
                    }
                    else if (value.phase === 'relax-pushed') {
                         delay = Math.max(base * 0.6, duration + 20);
                    }
                    else if (value.phase === 'relax-sorted') {
                        delay = Math.max(base * 0.5, duration * 1.5);
                    }
                    else if (value.phase === 'post-sort-wait') {
                         delay = Math.max(base * 0.2, duration * 0.5);
                    }
                    else if (value.phase === 'pre-pop') {
                         delay = Math.max(base * 0.4, duration);
                    }
                    else if (value.phase === 'no-relax-highlight' || value.phase === 'skip-highlight') {
                        delay = Math.max(delay, duration * 2);
                    }

                    runnerTimeout.current = window.setTimeout(runStep, delay);
                } catch (error) {
                    console.error("Algorithm error:", error);
                    setErrorMessage("Error: " + error.message);
                    setIsRunning(false);
                }
            }, [isPaused, visualizationSpeed]);
            
            const handlePreview = () => {
                if (runnerTimeout.current) clearTimeout(runnerTimeout.current);
                setIsRunning(false); setIsPaused(false); setStepState(null);
                parseGraphData();
            };

            const handleStart = () => {
                if (isRunning) return;

                if (graphData) {
                    const startId = parseInt(startNode, 10), targetId = parseInt(targetNode, 10);
                    algorithmRunner.current = dijkstraWidestPath(graphData, startId, targetId);
                    setIsPaused(false); setIsRunning(true);
                } else {
                    if (parseGraphData()) {
                        setStartTriggered(true);
                    }
                }
            };

            useEffect(() => {
                if (graphData && startTriggered) {
                    setStartTriggered(false); // Reset trigger
                    const startId = parseInt(startNode, 10), targetId = parseInt(targetNode, 10);
                    algorithmRunner.current = dijkstraWidestPath(graphData, startId, targetId);
                    setIsPaused(false); setIsRunning(true);
                }
            }, [graphData, startTriggered, startNode, targetNode]);
            
            useEffect(() => {
                if (isRunning && !isPaused) runStep();
                else if (runnerTimeout.current) clearTimeout(runnerTimeout.current);
                return () => { if (runnerTimeout.current) clearTimeout(runnerTimeout.current); };
            }, [isRunning, isPaused, runStep]);
            
            const handlePause = () => setIsPaused(!isPaused);
            
            const showInfoPanel = isRunning || stepState?.phase === 'finished';

            return (
                <div className="flex flex-col md:flex-row h-screen overflow-hidden">
                    {/* LEFT SIDEBAR: INPUTS */}
                    <aside className="w-full md:w-[320px] p-4 bg-gray-800 shadow-lg flex flex-col space-y-4 overflow-y-auto border-r border-gray-700 z-20 flex-shrink-0">
                        <header>
                            <h1 className="text-2xl font-bold text-cyan-400 mb-1">Modified Dijkstra</h1>
                            <p className="text-xs text-gray-400">Modified Dijkstra for maximizing the minimum edge weight along the path.</p>
                        </header>
                        <div className="flex-grow min-h-0">
                            <div className="space-y-4">
                                <div>
                                    <label htmlFor="edges-input" className="block text-sm font-medium text-gray-300 mb-1">Graph Edges (u v w)</label>
                                    <textarea id="edges-input" rows={10} value={edgesInput} onChange={e => setEdgesInput(e.target.value)} disabled={isRunning} className="w-full bg-gray-900 border border-gray-600 rounded-md p-2 text-gray-200 focus:ring-cyan-500 focus:border-cyan-500 font-mono text-sm"></textarea>
                                </div>
                                <div className="grid grid-cols-2 gap-4">
                                    <div>
                                        <label htmlFor="start-node-input" className="block text-sm font-medium text-gray-300 mb-1">Start</label>
                                        <input type="number" id="start-node-input" value={startNode} onChange={e => setStartNode(e.target.value)} disabled={isRunning} className="w-full bg-gray-900 border border-gray-600 rounded-md p-2 text-gray-200 focus:ring-cyan-500 focus:border-cyan-500" />
                                    </div>
                                    <div>
                                        <label htmlFor="target-node-input" className="block text-sm font-medium text-gray-300 mb-1">Target</label>
                                        <input type="number" id="target-node-input" value={targetNode} onChange={e => setTargetNode(e.target.value)} disabled={isRunning} className="w-full bg-gray-900 border border-gray-600 rounded-md p-2 text-gray-200 focus:ring-cyan-500 focus:border-cyan-500" />
                                    </div>
                                </div>
                                <button onClick={handlePreview} className="w-full flex items-center justify-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-gray-600 hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-800 focus:ring-cyan-500 transition-colors">
                                    Preview Graph
                                </button>
                                <p className="text-rose-400 text-sm mt-2 min-h-[20px]">{errorMessage}</p>
                            </div>
                        </div>
                    </aside>

                    {/* MAIN: GRAPH VISUALIZATION */}
                    <main className="flex-1 p-4 grid place-items-center bg-graph relative min-w-0">
                        {!graphData && (
                            <div className="text-center text-gray-600">
                                <h2 className="text-2xl font-bold">Setup your graph</h2>
                                <p>Define your graph on the left and click "Preview" or "Start".</p>
                            </div>
                        )}
                        <GraphVisualizer graphData={graphData} stepState={stepState} duration={currentDuration} />
                    </main>

                    {/* NEW SIDEBAR: PRIORITY QUEUE (Separate Column) */}
                    {showInfoPanel && stepState && (
                        <aside className="w-full md:w-[280px] flex-shrink-0 bg-gray-800 border-l border-gray-700 flex flex-col z-10 shadow-lg">
                            <div className="p-4 bg-gray-800/95 backdrop-blur sticky top-0 z-10 border-b border-gray-700">
                                <h3 className="text-base font-bold text-cyan-400">Priority Queue</h3>
                                <p className="text-xs font-bold text-gray-500 uppercase tracking-wider mt-1">Live Ranking</p>
                            </div>
                            <div className="flex-1 overflow-y-auto p-2 scrollbar-thin">
                                <div ref={pqContainerRef} className="flex flex-col space-y-2 pb-4">
                                    {stepState.pq.length === 0 && <span className="text-gray-600 italic px-2 py-1 text-sm">Empty Queue</span>}
                                    {stepState.pq.map((item, index) => (
                                        <div 
                                            key={item.key} 
                                            data-key={item.key}
                                            className={`pq-item w-full flex items-center justify-between p-2 rounded border font-mono shadow-sm 
                                                ${stepState.phase === 'pre-pop' && stepState.poppedKey === item.key
                                                    ? 'opacity-0 scale-95 -translate-x-full'
                                                    : 'opacity-100 scale-100 translate-x-0'}
                                                ${index === 0 ? 'bg-gray-600 border-cyan-500 text-white' : 'bg-gray-700 border-gray-600 text-cyan-300'}
                                            `}
                                        >
                                            <span className="flex items-center">
                                                <span className="text-xs text-gray-400 font-sans mr-3 bg-gray-800 w-6 h-6 flex items-center justify-center rounded-full">{index + 1}</span>
                                                Node: <b className="text-yellow-400 mx-1">{item.id}</b>
                                            </span>
                                            <span>
                                                Cap: <b className={index === 0 ? 'text-white' : 'text-cyan-200'}>{item.h === MOD ? '∞' : item.h}</b>
                                            </span>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        </aside>
                    )}

                    {/* RIGHT SIDEBAR: STATUS, LOGS, CONTROLS */}
                    <aside className="w-full md:w-[350px] p-4 bg-gray-800 shadow-lg flex flex-col space-y-4 border-l border-gray-700 z-20 flex-shrink-0">
                        <div className="flex-grow min-h-0 panel-container overflow-y-auto">
                            {!showInfoPanel && (
                                 <div className="flex-grow flex flex-col items-center justify-center text-center text-gray-500">
                                    <h2 className="text-xl font-bold">Simulation Controls</h2>
                                    <p className="text-sm">Click "Start" to begin the algorithm visualization.</p>
                                </div>
                            )}
                            
                            {showInfoPanel && stepState && (
                                <div className="flex flex-col space-y-4 text-xs">
                                    <div className="p-3 bg-gray-900/50 rounded-lg border border-gray-700">
                                         <h3 className="text-base font-bold text-cyan-400 mb-2">Algorithm Status</h3>
                                         <div className="space-y-2">
                                             <div className="flex justify-between items-center">
                                                <span className="font-semibold text-gray-400">Current Node (u):</span>
                                                <span className="font-mono bg-gray-700 px-2 py-1 rounded text-yellow-400">{stepState.u ?? 'N/A'}</span>
                                            </div>
                                            <div className="flex justify-between items-center">
                                                <span className="font-semibold text-gray-400">Current Best Capacity:</span>
                                                <span className="font-mono bg-gray-700 px-2 py-1 rounded text-cyan-300">{stepState.u ? (stepState.heights[stepState.u] === MOD ? '∞' : stepState.heights[stepState.u]) : 'N/A'}</span>
                                            </div>
                                         </div>
                                    </div>

                                    <div className="p-3 bg-gray-900/50 rounded-lg border border-gray-700">
                                        <h3 className="text-base font-bold text-cyan-400 mb-2">Results</h3>
                                        <div className="space-y-2">
                                            <div className="flex justify-between items-center">
                                                <span className="font-semibold text-gray-400">Max Bottleneck Capacity:</span>
                                                <span className="font-mono bg-emerald-500/20 text-emerald-300 px-2 py-1 rounded">{stepState.heights[parseInt(targetNode)] > 0 ? stepState.heights[parseInt(targetNode)] : 'N/A'}</span>
                                            </div>
                                             <div>
                                                <span className="font-semibold text-gray-400">Trace Path:</span>
                                                <p className="font-mono bg-emerald-500/20 text-emerald-300 p-2 rounded break-words mt-1">{stepState.path ? stepState.path.join(' → ') : '[]'}</p>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <div className="pt-2 flex-grow flex flex-col min-h-0">
                                        <span className="font-semibold text-gray-400 block mb-1 uppercase tracking-tighter text-xs font-bold">Execution Log:</span>
                                        <div className="font-mono p-3 rounded text-white bg-gray-900 border border-gray-700 text-[14px] leading-tight overflow-y-auto max-h-[150px]">
                                            {stepState.log}
                                        </div>
                                    </div>
                                </div>
                            )}
                        </div>

                        <div className="flex-shrink-0 space-y-4 pt-4 border-t border-gray-700 bg-gray-800">
                            <div>
                                <div className="flex justify-between text-sm mb-1">
                                    <label htmlFor="speed-slider" className="font-medium text-gray-300">Speed</label>
                                </div>
                                <input type="range" id="speed-slider" min="50" max="2000" step="50" value={visualizationSpeed} onChange={e => setVisualizationSpeed(parseInt(e.target.value))} className="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer" />
                            </div>
                            <div className="flex space-x-2">
                                <button onClick={handleStart} disabled={isRunning} className="flex-1 flex items-center justify-center px-4 py-2 border border-transparent text-base font-medium rounded-md shadow-sm text-white bg-cyan-600 hover:bg-cyan-700 disabled:bg-gray-500 disabled:cursor-not-allowed">Start</button>
                                <button onClick={handlePause} disabled={!isRunning || stepState?.phase === 'finished'} className="flex-1 flex items-center justify-center px-4 py-2 border border-transparent text-base font-medium rounded-md shadow-sm text-white bg-yellow-500 hover:bg-yellow-600 disabled:bg-gray-500 disabled:cursor-not-allowed">{isPaused ? 'Resume' : 'Pause'}</button>
                                <button onClick={resetState} className="flex-1 flex items-center justify-center px-4 py-2 border border-transparent text-base font-medium rounded-md shadow-sm text-white bg-red-600 hover:bg-red-700">Reset</button>
                            </div>
                        </div>
                    </aside>
                </div>
            );
        }

        // --- From index.tsx ---
        const rootElement = document.getElementById('root');
        const root = ReactDOM.createRoot(rootElement);
        root.render(<App />);

    </script>
</body>
</html>
