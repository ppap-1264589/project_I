
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Backtracking</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        .hidden-panel { display: none !important; }
        /* Ensure consistent height for panels in a row */
        .panel-container {
            display: flex;
            flex-direction: column;
        }
        /* Consistent scrollbar styling */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #1f2937; }
        ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 10px; }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 font-sans overflow-hidden">
    <div class="flex flex-col md:flex-row h-screen overflow-hidden">
        
        <!-- Left Panel: Setup -->
        <aside class="w-full md:w-[350px] p-4 bg-gray-800 shadow-lg flex flex-col space-y-4 overflow-y-auto z-20 border-r border-gray-700">
            <header>
                <h1 class="text-2xl font-bold text-cyan-400 mb-1">Backtracking</h1>
                <p class="text-xs text-gray-400">Backtracking to find the path where the minimum edge weight is maximized.</p>
            </header>

            <div class="flex-grow min-h-0">
                <div id="setup-panel" class="space-y-4">
                    <div>
                        <label for="edges-input" class="block text-sm font-medium text-gray-300 mb-1">Graph Edges (u v w)</label>
                        <textarea id="edges-input" rows="10" class="w-full bg-gray-900 border border-gray-600 rounded-md p-2 text-gray-200 focus:ring-cyan-500 focus:border-cyan-500 font-mono text-sm"></textarea>
                    </div>
                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <label for="start-node-input" class="block text-sm font-medium text-gray-300 mb-1">Start</label>
                            <input type="number" id="start-node-input" class="w-full bg-gray-900 border border-gray-600 rounded-md p-2 text-gray-200 focus:ring-cyan-500 focus:border-cyan-500" value="1" />
                        </div>
                        <div>
                            <label for="target-node-input" class="block text-sm font-medium text-gray-300 mb-1">Target</label>
                            <input type="number" id="target-node-input" class="w-full bg-gray-900 border border-gray-600 rounded-md p-2 text-gray-200 focus:ring-cyan-500 focus:border-cyan-500" value="5" />
                        </div>
                    </div>
                    <button id="preview-button" class="w-full flex items-center justify-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-gray-600 hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-800 focus:ring-cyan-500 transition-colors">
                        Preview Graph
                    </button>
                    <p id="error-message" class="text-red-400 text-sm mt-2 min-h-[20px]"></p>
                </div>
            </div>
        </aside>

        <!-- Center Panel: Visualization -->
        <main id="vis-container" class="flex-1 p-4 flex items-center justify-center bg-gray-900 relative">
            <div id="placeholder-text" class="text-center text-gray-500">
                <h2 class="text-2xl font-bold">Setup your graph</h2>
                <p>Define your graph on the left and click "Preview" or "Start".</p>
            </div>
            <svg id="vis-canvas" class="absolute top-0 left-0 w-full h-full"></svg>
        </main>

        <!-- Right Panel: Info & Controls -->
        <aside class="w-full md:w-[450px] p-4 bg-gray-800 shadow-lg flex flex-col space-y-4 overflow-y-auto z-20 border-l border-gray-700">
            <div id="info-container" class="flex-grow min-h-0 panel-container">
                 <!-- Placeholder before starting -->
                <div id="info-placeholder" class="flex-grow flex flex-col items-center justify-center text-center text-gray-500">
                    <h2 class="text-xl font-bold">Simulation Controls</h2>
                    <p class="text-sm">Click "Start" to begin the algorithm visualization.</p>
                </div>
                
                <!-- Info Panel during simulation -->
                <div id="info-panel" class="h-full flex-col hidden-panel">
                     <h2 class="text-xl font-bold text-cyan-400 mb-4">Simulation Status</h2>
                    <div class="space-y-3 text-sm flex-grow overflow-y-auto pr-1">
                        <div class="p-3 bg-gray-900/50 rounded-lg border border-gray-700">
                            <h3 class="text-base font-bold text-cyan-400 mb-2">Current State</h3>
                            <div class="space-y-2">
                                <div class="flex justify-between items-center">
                                    <span class="font-semibold text-gray-400">Current Node:</span>
                                    <span id="current-node" class="font-mono bg-gray-700 px-2 py-1 rounded text-yellow-400">N/A</span>
                                </div>
                                <div class="flex justify-between items-center">
                                    <span class="font-semibold text-gray-400">Min Weight (Current):</span>
                                    <span id="current-min-weight" class="font-mono bg-gray-700 px-2 py-1 rounded text-cyan-300">N/A</span>
                                </div>
                                <div>
                                    <span class="font-semibold text-gray-400">Current Path:</span>
                                    <p id="current-path" class="font-mono bg-gray-700 p-2 rounded break-words mt-1 text-gray-300">[]</p>
                                </div>
                            </div>
                        </div>

                        <div class="p-3 bg-gray-900/50 rounded-lg border border-gray-700">
                            <h3 class="text-base font-bold text-cyan-400 mb-2">Best Result So Far</h3>
                            <div class="space-y-2">
                                <div class="flex justify-between items-center">
                                    <span class="font-semibold text-gray-400">Min Weight (Best):</span>
                                    <span id="best-min-weight" class="font-mono bg-emerald-500/20 text-emerald-300 px-2 py-1 rounded">N/A</span>
                                </div>
                                <div>
                                    <span class="font-semibold text-gray-400">Best Path Found:</span>
                                    <p id="best-path" class="font-mono bg-emerald-500/20 text-emerald-300 p-2 rounded break-words mt-1">[]</p>
                                </div>
                            </div>
                        </div>
                        
                        <div class="p-3 bg-gray-900/50 rounded-lg border border-gray-700">
                            <h3 class="text-base font-bold text-cyan-400 mb-2">Algorithm Cost</h3>
                            <div class="space-y-2">
                                <div class="flex justify-between items-center">
                                    <span class="font-semibold text-gray-400">Total Nodes Visited:</span>
                                    <span id="nodes-visited-count" class="font-mono bg-gray-700 px-2 py-1 rounded text-green-400">0</span>
                                </div>
                                <div class="flex justify-between items-center">
                                    <span class="font-semibold text-gray-400">Total Edges Explored:</span>
                                    <span id="edges-explored-count" class="font-mono bg-gray-700 px-2 py-1 rounded text-blue-400">0</span>
                                </div>
                            </div>
                        </div>

                        <div class="pt-2">
                            <span class="font-semibold text-gray-400 block mb-1">Log:</span>
                            <p id="log-message" class="font-mono p-3 rounded text-white bg-gray-900 border border-gray-700">Waiting to start...</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Global Controls -->
            <div class="flex-shrink-0 space-y-4 pt-4 border-t border-gray-700 bg-gray-800">
                <div>
                    <label for="speed-slider" class="block text-sm font-medium text-gray-300 mb-1">Speed</label>
                    <input type="range" id="speed-slider" min="50" max="2000" step="50" value="1550" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer" />
                </div>
                <div class="flex space-x-2">
                    <button id="start-button" class="flex-1 flex items-center justify-center px-4 py-2 border border-transparent text-base font-medium rounded-md shadow-sm text-white bg-cyan-600 hover:bg-cyan-700 disabled:bg-gray-500 disabled:cursor-not-allowed transition-colors">Start</button>
                    <button id="pause-button" class="flex-1 flex items-center justify-center px-4 py-2 border border-transparent text-base font-medium rounded-md shadow-sm text-white bg-yellow-500 hover:bg-yellow-600 disabled:bg-gray-500 disabled:cursor-not-allowed transition-colors">Pause</button>
                    <button id="reset-button" class="flex-1 flex items-center justify-center px-4 py-2 border border-transparent text-base font-medium rounded-md shadow-sm text-white bg-red-600 hover:bg-red-700 transition-colors">Reset</button>
                </div>
            </div>
        </aside>

    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- DOM Elements ---
    const edgesInput = document.getElementById('edges-input');
    const startNodeInput = document.getElementById('start-node-input');
    const targetNodeInput = document.getElementById('target-node-input');
    const previewButton = document.getElementById('preview-button');
    const startButton = document.getElementById('start-button');
    const pauseButton = document.getElementById('pause-button');
    const resetButton = document.getElementById('reset-button');
    const speedSlider = document.getElementById('speed-slider');
    const errorMessage = document.getElementById('error-message');
    
    const infoPlaceholder = document.getElementById('info-placeholder');
    const infoPanel = document.getElementById('info-panel');
    
    const currentNodeEl = document.getElementById('current-node');
    const currentMinWeightEl = document.getElementById('current-min-weight');
    const bestMinWeightEl = document.getElementById('best-min-weight');
    const currentPathEl = document.getElementById('current-path');
    const bestPathEl = document.getElementById('best-path');
    const logMessageEl = document.getElementById('log-message');
    const nodesVisitedCountEl = document.getElementById('nodes-visited-count');
    const edgesExploredCountEl = document.getElementById('edges-explored-count');

    const visContainer = document.getElementById('vis-container');
    const visCanvas = document.getElementById('vis-canvas');
    const placeholderText = document.getElementById('placeholder-text');
    const svg = d3.select(visCanvas);

    // --- State ---
    let graphData = null;
    let stepState = null;
    let isRunning = false;
    let isPaused = false;
    let visualizationSpeed = 500;
    let algorithmRunner = null;
    let runnerTimeout = null;
    let simulation = null;

    const defaultEdges = `1 2 20
1 3 15
1 4 10
2 3 8
2 5 12
3 4 5
3 5 10
4 5 7`;
    edgesInput.value = defaultEdges;

    // --- Core Functions ---
    const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

    function parseGraphData() {
        errorMessage.textContent = '';
        try {
            const lines = edgesInput.value.split('\n').filter(line => line.trim() !== '');
            if (lines.length === 0) throw new Error("Edge data is empty.");

            const firstLine = lines[0].split(' ').map(Number);
            let edgeLines;
            let n;
            
            if (firstLine.length === 2 && !isNaN(firstLine[0]) && !isNaN(firstLine[1])) {
                 n = firstLine[0];
                 edgeLines = lines.slice(1);
            } else {
                 edgeLines = lines;
                 const allNodeIds = new Set();
                 edgeLines.forEach(line => {
                    const [u, v] = line.split(' ').map(Number);
                    if (!isNaN(u)) allNodeIds.add(u);
                    if (!isNaN(v)) allNodeIds.add(v);
                 });
                 if (allNodeIds.size === 0) throw new Error("No valid nodes found in edges.");
                 n = Math.max(...allNodeIds);
            }

            const startNode = parseInt(startNodeInput.value);
            const targetNode = parseInt(targetNodeInput.value);

            if (isNaN(n) || isNaN(startNode) || isNaN(targetNode) || n <= 0 || startNode <= 0 || targetNode <= 0 || startNode > n || targetNode > n) {
                throw new Error("Invalid number of nodes, start, or target node.");
            }

            const nodes = Array.from({ length: n }, (_, i) => ({ id: i + 1 }));
            const edges = edgeLines.map((line, i) => {
                const parts = line.split(' ').map(Number);
                if (parts.length !== 3 || parts.some(isNaN)) {
                    throw new Error(`Invalid edge format on line ${i + (firstLine.length === 2 ? 1: 0)}: "${line}"`);
                }
                const [u, v, w] = parts;
                if (u <= 0 || v <= 0 || u > n || v > n || w <= 0) {
                     throw new Error(`Invalid edge data on line ${i + (firstLine.length === 2 ? 1: 0)}: nodes must be between 1 and ${n}, weight must be positive.`);
                }
                return { source: u, target: v, weight: w };
            });

            graphData = { nodes, edges };
            stepState = null;
            placeholderText.classList.add('hidden-panel');
            return true;
        } catch (e) {
            errorMessage.textContent = e.message;
            graphData = null;
            return false;
        }
    }

    async function* runWidestPathAlgorithm(graph, startNode, destination) {
      const adj = new Map();
      for (const edge of graph.edges) {
        if (!adj.has(edge.source)) adj.set(edge.source, []);
        if (!adj.has(edge.target)) adj.set(edge.target, []);
        adj.get(edge.source).push({ v: edge.target, w: edge.weight });
        adj.get(edge.target).push({ v: edge.source, w: edge.weight });
      }

      let best = -1;
      let truePath = [];
      const tempPath = [startNode];
      const marked = new Set([startNode]);
      let nodesVisitedCount = 1;
      let edgesExploredCount = 0;


      async function* tryStep(u, currentMin) {
        if (u === destination) {
          if (currentMin > best) {
            best = currentMin;
            truePath = [...tempPath];
            yield {
              currentNode: u, currentPath: [...tempPath], markedNodes: new Set(marked), bestPath: [...truePath],
              currentMinWeight: currentMin, bestMinWeight: best, logMessage: `Found new best path with min-weight ${best}.`,
              isUpdatingBest: true,
              nodesVisited: nodesVisitedCount, edgesExplored: edgesExploredCount,
            };
          } else {
             yield {
              currentNode: u, currentPath: [...tempPath], markedNodes: new Set(marked), bestPath: [...truePath],
              currentMinWeight: currentMin, bestMinWeight: best, logMessage: `Found path, but min-weight ${currentMin} not better than ${best}.`,
              isSuboptimalPathFound: true,
              nodesVisited: nodesVisitedCount, edgesExplored: edgesExploredCount,
            };
          }
          return;
        }

        const neighbors = adj.get(u) || [];
        for (const { v, w } of neighbors) {

          if (marked.has(v)) {
            edgesExploredCount++;
            yield {
              currentNode: u, currentPath: [...tempPath], markedNodes: new Set(marked), bestPath: [...truePath],
              currentMinWeight: currentMin, bestMinWeight: best, logMessage: `Node ${v} already visited. Skipping.`,
              consideringEdge: { source: u, target: v },
              isVisitingMarked: true,
              nodesVisited: nodesVisitedCount,
              edgesExplored: edgesExploredCount,
            };
            continue;
          }

          const newCurrMin = Math.min(currentMin, w);
          if (newCurrMin <= best) {
            edgesExploredCount++;
            yield {
              currentNode: u, currentPath: [...tempPath], markedNodes: new Set(marked), bestPath: [...truePath],
              currentMinWeight: currentMin, bestMinWeight: best, logMessage: `Pruning path to ${v}. New min-weight ${newCurrMin} <= best ${best}.`,
              consideringEdge: { source: u, target: v }, 
              isPruning: true,
              nodesVisited: nodesVisitedCount,
              edgesExplored: edgesExploredCount,
            };
            continue;
          }
          
          edgesExploredCount++;
          nodesVisitedCount++;
          marked.add(v);
          tempPath.push(v);
          yield {
            currentNode: v, currentPath: [...tempPath], markedNodes: new Set(marked), bestPath: [...truePath],
            currentMinWeight: newCurrMin, bestMinWeight: best, logMessage: `Moving to node ${v}. Path min-weight is ${newCurrMin}.`,
            consideringEdge: { source: u, target: v },
            nodesVisited: nodesVisitedCount,
            edgesExplored: edgesExploredCount,
          };
          
          yield* tryStep(v, newCurrMin);

          tempPath.pop();
          marked.delete(v);
          yield {
            currentNode: u, currentPath: [...tempPath], markedNodes: new Set(marked), bestPath: [...truePath],
            currentMinWeight: currentMin, bestMinWeight: best, logMessage: `Backtracking from ${v} to ${u}.`,
            consideringEdge: { source: u, target: v }, isBacktracking: true,
            backtrackingNode: v,
            nodesVisited: nodesVisitedCount,
            edgesExplored: edgesExploredCount,
          };
        }
      }

      yield {
        currentNode: startNode, currentPath: [startNode], markedNodes: new Set([startNode]), bestPath: [],
        currentMinWeight: Infinity, bestMinWeight: -1, logMessage: `Starting algorithm from node ${startNode}.`,
        nodesVisited: nodesVisitedCount, edgesExplored: edgesExploredCount,
      };

      yield* tryStep(startNode, Infinity);

      yield {
        currentNode: null,
        currentPath: [...truePath], 
        markedNodes: new Set(truePath),
        bestPath: [...truePath],
        currentMinWeight: best > -1 ? best : 0,
        bestMinWeight: best,
        logMessage: best > -1 ? `Algorithm finished. Best min-weight is ${best}.` : 'Algorithm finished. No path found.',
        isFinished: true,
        nodesVisited: nodesVisitedCount, edgesExplored: edgesExploredCount,
      };
    }

    // --- Visualization ---
    function updateVisualization(state) {
        if (!graphData || !state) return;

        const bestPathEdges = new Set();
        for (let i = 0; i < state.bestPath.length - 1; i++) {
            const u = state.bestPath[i];
            const v = state.bestPath[i + 1];
            bestPathEdges.add(`${Math.min(u,v)}-${Math.max(u,v)}`);
        }

        const currentPathEdges = new Set();
        for (let i = 0; i < state.currentPath.length - 1; i++) {
            const u = state.currentPath[i];
            const v = state.currentPath[i + 1];
            currentPathEdges.add(`${Math.min(u,v)}-${Math.max(u,v)}`);
        }
        
        let redNodeId = null;
        if (state.isBacktracking) {
            redNodeId = state.backtrackingNode;
        } else if (!state.isUpdatingBest && !state.isSuboptimalPathFound) {
            redNodeId = state.currentNode;
        }

        svg.selectAll("circle.node")
          .transition().duration(200)
          .attr("fill", d => {
              if (state.isFinished) {
                  return state.bestPath.includes(d.id) ? "#4ade80" : "#1f2937";
              }
              if (state.isUpdatingBest) {
                  return state.currentPath.includes(d.id) ? "#4ade80" : "#1f2937"; // Green for new best path nodes
              }
              if (state.isSuboptimalPathFound) {
                  return state.currentPath.includes(d.id) ? "#38bdf8" : "#1f2937"; // Blue for suboptimal path nodes
              }
              if (d.id === redNodeId) return "#ef4444";
              if (state.currentPath.includes(d.id)) return "#facc15"; // Yellow for current DFS path
              return "#1f2937";
          })
          .attr("stroke", d => {
               if (d.id === redNodeId || state.currentPath.includes(d.id)) return "#fff";
               return "#4b5563";
          })
          .attr("r", d => (state.currentPath.includes(d.id) || (state.isFinished && state.bestPath.includes(d.id))) ? 25 : 20);

        svg.selectAll("line.link")
          .transition().duration(200)
          .attr("stroke", d => {
              const edgeId = `${Math.min(d.source.id, d.target.id)}-${Math.max(d.source.id, d.target.id)}`;
              const consideringEdgeId = state.consideringEdge ? `${Math.min(state.consideringEdge.source, state.consideringEdge.target)}-${Math.max(state.consideringEdge.source, state.consideringEdge.target)}` : null;

              if (edgeId === consideringEdgeId) {
                  if (state.isVisitingMarked) return "#a855f7"; // Purple
              }

              if (state.isFinished) {
                  return bestPathEdges.has(edgeId) ? "#4ade80" : "#374151";
              }
              if (state.isUpdatingBest && currentPathEdges.has(edgeId)) return "#4ade80";
              if (state.isSuboptimalPathFound && currentPathEdges.has(edgeId)) return "#38bdf8";
              if (currentPathEdges.has(edgeId)) return "#facc15";
              return "#374151";
          })
          .attr("stroke-opacity", d => {
              const edgeId = `${Math.min(d.source.id, d.target.id)}-${Math.max(d.source.id, d.target.id)}`;
              if (currentPathEdges.has(edgeId) || (state.isFinished && bestPathEdges.has(edgeId))) {
                  return 1;
              }
              if (state.bestMinWeight > -1 && d.weight <= state.bestMinWeight) {
                  return 0.15; // Heavily dim prunable edges
              }
              return 0.6; // Default opacity
          })
          .attr("stroke-width", d => {
              const edgeId = `${Math.min(d.source.id, d.target.id)}-${Math.max(d.source.id, d.target.id)}`;
              const baseWidth = Math.max(2, Math.sqrt(d.weight / 2));
              return (currentPathEdges.has(edgeId) || (state.isFinished && bestPathEdges.has(edgeId))) ? baseWidth + 4 : baseWidth;
          });
        
        // Pruning 'X' mark visualization
        const prunedEdgeData = [];
        if (state.isPruning && state.consideringEdge) {
            const ce = state.consideringEdge;
            const allEdges = svg.selectAll("line.link").data(); 
            const foundEdge = allEdges.find(d => 
                (d.source.id === ce.source && d.target.id === ce.target) ||
                (d.source.id === ce.target && d.target.id === ce.source)
            );
            if (foundEdge) {
                prunedEdgeData.push(foundEdge);
            }
        }
        
        svg.selectAll(".prune-mark").remove();
        if (prunedEdgeData.length > 0) {
            svg.append("g").selectAll("text")
                .data(prunedEdgeData)
                .join("text")
                .attr("class", "prune-mark")
                .attr("fill", "#ef4444") // red-500
                .attr("font-size", "24px")
                .attr("font-weight", "bold")
                .attr("text-anchor", "middle")
                .attr("dy", ".35em")
                .text("✖")
                .attr("x", d => (d.source.x + d.target.x) / 2)
                .attr("y", d => (d.source.y + d.target.y) / 2);
        }
    }

    function resetVisualizationStyles() {
        if (!graphData) return;
        svg.selectAll("circle.node")
            .transition().duration(200)
            .attr("fill", "#1f2937")
            .attr("r", 20);

        svg.selectAll("line.link")
            .transition().duration(200)
            .attr("stroke", "#374151")
            .attr("stroke-opacity", 0.6)
            .attr("stroke-width", d => Math.max(2, Math.sqrt(d.weight / 2)));

        svg.selectAll(".prune-mark").remove();
    }

    function initializeVisualization() {
        if (!graphData) return;
        svg.selectAll("*").remove();
        
        const width = visContainer.offsetWidth;
        const height = visContainer.offsetHeight;
        visCanvas.setAttribute('width', width);
        visCanvas.setAttribute('height', height);

        const nodes = JSON.parse(JSON.stringify(graphData.nodes));
        const edges = JSON.parse(JSON.stringify(graphData.edges));

        if (simulation) simulation.stop();

        // --- UPDATED D3 FORCE SETUP ---
        simulation = d3.forceSimulation(nodes)
          .force("link", d3.forceLink(edges).id(d => d.id).distance(120)) // Reduced distance
          .force("charge", d3.forceManyBody().strength(-1000)) // Stronger repulsion
          .force("center", d3.forceCenter(width / 2, height / 2))
          .force("collide", d3.forceCollide().radius(35).iterations(2)); // Add collision

        // --- PRE-WARMING ---
        simulation.stop();
        simulation.tick(300);
        simulation.restart();

        // Initialize elements with coordinates from pre-warmed nodes
        const link = svg.append("g").selectAll("line").data(edges).join("line")
          .attr("class", "link")
          .attr("stroke", "#374151").attr("stroke-opacity", 0.6)
          .attr("stroke-width", d => Math.max(2, Math.sqrt(d.weight / 2)))
          .attr("x1", d => d.source.x).attr("y1", d => d.source.y)
          .attr("x2", d => d.target.x).attr("y2", d => d.target.y);

        const edgeLabels = svg.append("g").selectAll("text").data(edges).join("text")
          .attr("class", "text-xs fill-gray-500 font-bold pointer-events-none")
          .attr("text-anchor", "middle")
          .text(d => d.weight)
          .attr("x", d => (d.source.x + d.target.x) / 2)
          .attr("y", d => (d.source.y + d.target.y) / 2);

        const node = svg.append("g").selectAll("circle").data(nodes).join("circle")
          .attr("class", "node")
          .attr("r", 20).attr("fill", "#1f2937")
          .attr("stroke", "#4b5563").attr("stroke-width", 2)
          .attr("cx", d => d.x).attr("cy", d => d.y)
          .call(drag(simulation));

        const nodeLabels = svg.append("g").selectAll("text").data(nodes).join("text")
          .attr("class", "text-sm fill-current text-white font-bold pointer-events-none")
          .attr("text-anchor", "middle").attr("dy", ".35em")
          .text(d => d.id)
          .attr("x", d => d.x).attr("y", d => d.y);

        simulation.on("tick", () => {
          link.attr("x1", d => d.source.x).attr("y1", d => d.source.y)
              .attr("x2", d => d.target.x).attr("y2", d => d.target.y);
          edgeLabels.attr("x", d => (d.source.x + d.target.x) / 2)
                    .attr("y", d => (d.source.y + d.target.y) / 2);
          node.attr("cx", d => d.x).attr("cy", d => d.y);
          nodeLabels.attr("x", d => d.x).attr("y", d => d.y);
        });
    }

    function drag(simulation) {
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x; d.fy = d.y;
        }
        function dragged(event, d) {
            d.fx = event.x; d.fy = event.y;
        }
        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null; d.fy = null;
        }
        return d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended);
    }

    // --- UI Update & Control Flow ---
    function updateInfoPanel(state) {
        if (!state && stepState?.isFinished) { // Persist final state
            state = stepState;
        } else if (!state) { // Clear if resetting
             state = {};
        }

        currentNodeEl.textContent = state?.currentNode ?? 'N/A';
        currentMinWeightEl.textContent = state?.currentMinWeight === Infinity ? '∞' : state?.currentMinWeight > -1 ? state.currentMinWeight.toFixed(0) : 'N/A';
        bestMinWeightEl.textContent = state?.bestMinWeight > -1 ? state.bestMinWeight.toFixed(0) : 'N/A';
        currentPathEl.textContent = state?.currentPath?.join(' → ') ?? '[]';
        bestPathEl.textContent = state?.bestPath?.join(' → ') ?? '[]';
        logMessageEl.textContent = state?.logMessage ?? '...';
        nodesVisitedCountEl.textContent = state?.nodesVisited ?? '0';
        edgesExploredCountEl.textContent = state?.edgesExplored ?? '0';
        
        logMessageEl.className = 'font-mono p-3 rounded mt-1 text-white text-xs border border-gray-700 transition-colors'; // reset
        if(state?.isPruning) logMessageEl.classList.add('bg-red-900/40');
        else if(state?.isVisitingMarked) logMessageEl.classList.add('bg-purple-900/40');
        else if(state?.isUpdatingBest) logMessageEl.classList.add('bg-green-900/30');
        else if(state?.isSuboptimalPathFound) logMessageEl.classList.add('bg-sky-900/30');
        else logMessageEl.classList.add('bg-gray-900');
    }
    
    function setRunningState(running, paused = false) {
        isRunning = running;
        isPaused = paused;
        startButton.disabled = running;
        pauseButton.disabled = !running || stepState?.isFinished;

        if (running || stepState?.isFinished) {
            infoPlaceholder.classList.add('hidden-panel');
            infoPanel.classList.add('flex'); // Use flex to show
            infoPanel.classList.remove('hidden-panel');
        } else {
            infoPlaceholder.classList.remove('hidden-panel');
            infoPanel.classList.remove('flex');
            infoPanel.classList.add('hidden-panel');
        }
        pauseButton.textContent = paused ? 'Resume' : 'Pause';
    }

    async function runStep() {
        if (!algorithmRunner || isPaused) return;

        const { value, done } = await algorithmRunner.next();
        stepState = value;
        
        if(value) {
             updateInfoPanel(value);
             updateVisualization(value);
        }

        if (done || value?.isFinished) {
            setRunningState(false);
            if (runnerTimeout) clearTimeout(runnerTimeout);
            // Final state is already set by the last yield, just ensure UI reflects it
            updateInfoPanel(stepState); 
            updateVisualization(stepState);
            startButton.disabled = false; // Re-enable start button after finishing
            return;
        }
        
        runnerTimeout = setTimeout(runStep, visualizationSpeed);
    }
    
    // --- Event Handlers ---
    function handleStart() {
        if (isRunning) return;

        if (!graphData) {
            if (!parseGraphData()) return;
        }

        if (stepState?.isFinished) {
            stepState = null;
        }
        clearTimeout(runnerTimeout);

        if (!simulation) {
            initializeVisualization();
        } else {
            resetVisualizationStyles();
        }

        const startNode = parseInt(startNodeInput.value);
        const targetNode = parseInt(targetNodeInput.value);
        algorithmRunner = runWidestPathAlgorithm(graphData, startNode, targetNode);
        
        setRunningState(true, false);
        runStep();
    }
    
    function handlePauseToggle() {
        if (!isRunning) return;
        const newPausedState = !isPaused;
        setRunningState(true, newPausedState);
        if (!newPausedState) {
            setTimeout(runStep, 100);
        }
    }

    function handleReset() {
        if (runnerTimeout) clearTimeout(runnerTimeout);
        if (simulation) {
            simulation.stop();
            simulation = null;
        }
        
        stepState = null;
        graphData = null;
        algorithmRunner = null;
        svg.selectAll("*").remove();
        placeholderText.classList.remove('hidden-panel');
        setRunningState(false);
        updateInfoPanel(null);
    }

    // --- Initial Setup & Listeners ---
    previewButton.addEventListener('click', () => {
        handleReset(); // Reset completely before showing a new preview
        if (parseGraphData()) {
            initializeVisualization();
        }
    });
    startButton.addEventListener('click', handleStart);
    pauseButton.addEventListener('click', handlePauseToggle);
    resetButton.addEventListener('click', handleReset);
    speedSlider.addEventListener('input', (e) => {
        visualizationSpeed = 2050 - parseInt(e.target.value);
    });

    const resizeObserver = new ResizeObserver(entries => {
        if (!entries.length) return;
        if(graphData) {
            initializeVisualization();
            if(stepState) {
                updateVisualization(stepState);
            }
        }
    });
    resizeObserver.observe(visContainer);

    // Set initial speed
    visualizationSpeed = 2050 - parseInt(speedSlider.value);
    setRunningState(false);
});
</script>
</body>
</html>
