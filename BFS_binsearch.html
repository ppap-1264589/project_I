
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>BFS + Binary Search</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        .hidden-panel { display: none !important; }
        .panel-container {
            display: flex;
            flex-direction: column;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 font-sans">
    <div class="flex flex-col md:flex-row h-screen overflow-hidden">
        
        <!-- Left Panel: Setup -->
        <aside class="w-full md:w-[350px] p-4 bg-gray-800 shadow-lg flex flex-col space-y-4 overflow-y-auto">
            <header>
                <h1 class="text-2xl font-bold text-cyan-400 mb-1">Widest Path Visualizer</h1>
                <p class="text-xs text-gray-400">Binary Search + BFS to maximize minimum edge weight.</p>
            </header>

            <div class="flex-grow min-h-0">
                <div id="setup-panel" class="space-y-4">
                    <div>
                        <label for="edges-input" class="block text-sm font-medium text-gray-300 mb-1">Graph Edges (u v w)</label>
                        <textarea id="edges-input" rows="10" class="w-full bg-gray-900 border border-gray-600 rounded-md p-2 text-gray-200 focus:ring-cyan-500 focus:border-cyan-500 font-mono text-sm"></textarea>
                    </div>
                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <label for="start-node-input" class="block text-sm font-medium text-gray-300 mb-1">Start</label>
                            <input type="number" id="start-node-input" class="w-full bg-gray-900 border border-gray-600 rounded-md p-2 text-gray-200 focus:ring-cyan-500 focus:border-cyan-500" value="1" />
                        </div>
                        <div>
                            <label for="target-node-input" class="block text-sm font-medium text-gray-300 mb-1">Target</label>
                            <input type="number" id="target-node-input" class="w-full bg-gray-900 border border-gray-600 rounded-md p-2 text-gray-200 focus:ring-cyan-500 focus:border-cyan-500" value="5" />
                        </div>
                    </div>
                    <button id="preview-button" class="w-full flex items-center justify-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-gray-600 hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-800 focus:ring-cyan-500">
                        Preview Graph
                    </button>
                    <p id="error-message" class="text-red-400 text-sm mt-2 min-h-[20px]"></p>
                </div>
            </div>
        </aside>

        <!-- Center Panel: Visualization -->
        <main id="vis-container" class="flex-1 p-4 flex items-center justify-center bg-gray-900 relative">
            <div id="placeholder-text" class="text-center text-gray-500">
                <h2 class="text-2xl">Setup your graph</h2>
                <p>Define your graph on the left and click "Preview" or "Start".</p>
            </div>
            <svg id="vis-canvas" class="absolute top-0 left-0"></svg>
        </main>

        <!-- Right Panel: Info & Controls -->
        <aside class="w-full md:w-[450px] p-4 bg-gray-800 shadow-lg flex flex-col space-y-4">
            <div id="info-container" class="flex-grow min-h-0 panel-container overflow-y-auto">
                <div id="info-placeholder" class="flex-grow flex flex-col items-center justify-center text-center text-gray-500">
                    <h2 class="text-xl font-bold">Simulation Controls</h2>
                    <p class="text-sm">Click "Start" to begin the algorithm visualization.</p>
                </div>
                
                <div id="info-panel" class="flex flex-col hidden-panel space-y-2 text-xs">
                    <div class="p-2 bg-gray-900/50 rounded-lg">
                        <h3 class="text-base font-bold text-cyan-400 mb-1">Binary Search</h3>
                        <div class="space-y-1">
                            <div class="flex justify-between items-center">
                                <span class="font-semibold text-gray-400">Range [L, R):</span>
                                <span id="bs-range" class="font-mono bg-gray-700 px-2 py-1 rounded"></span>
                            </div>
                             <div class="flex justify-between items-center">
                                <span class="font-semibold text-gray-400">Mid Threshold:</span>
                                <span id="bs-mid" class="font-mono bg-gray-700 px-2 py-1 rounded"></span>
                            </div>
                            <div class="flex justify-between items-center">
                                <span class="font-semibold text-gray-400">canPass(mid):</span>
                                <span id="bs-canpass" class="font-mono bg-gray-700 px-2 py-1 rounded"></span>
                            </div>
                        </div>
                    </div>

                    <div class="p-2 bg-gray-900/50 rounded-lg">
                         <h3 id="bfs-status-header" class="text-base font-bold text-cyan-400 mb-1">BFS Status</h3>
                         <div class="space-y-1">
                             <div class="flex justify-between items-center">
                                <span class="font-semibold text-gray-400">Current Node:</span>
                                <span id="bfs-current-node" class="font-mono bg-gray-700 px-2 py-1 rounded">N/A</span>
                            </div>
                            <div>
                                <span class="font-semibold text-gray-400">Queue:</span>
                                <p id="bfs-queue" class="font-mono bg-gray-700 p-1 rounded break-words mt-1">[]</p>
                            </div>
                         </div>
                    </div>

                    <div class="p-2 bg-gray-900/50 rounded-lg">
                        <h3 class="text-base font-bold text-cyan-400 mb-1">Overall Best Result</h3>
                        <div class="space-y-1">
                            <div class="flex justify-between items-center">
                                <span class="font-semibold text-gray-400">Best Min-Weight:</span>
                                <span id="best-min-weight" class="font-mono bg-green-500/20 text-green-300 px-2 py-1 rounded">N/A</span>
                            </div>
                             <div>
                                <span class="font-semibold text-gray-400">Best Path Found:</span>
                                <p id="best-path" class="font-mono bg-green-500/20 text-green-300 p-1 rounded break-words mt-1">[]</p>
                            </div>
                        </div>
                    </div>
                     
                    <div class="pt-1">
                        <span class="font-semibold text-gray-400">Log:</span>
                        <p id="log-message" class="font-mono p-2 rounded mt-1 text-white bg-gray-700"></p>
                    </div>
                </div>
            </div>

            <!-- Global Controls -->
            <div class="flex-shrink-0 space-y-4 pt-4 border-t border-gray-700">
                <div>
                    <label for="speed-slider" class="block text-sm font-medium text-gray-300 mb-1">Speed</label>
                    <input type="range" id="speed-slider" min="50" max="2000" step="50" value="1550" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer" />
                </div>
                <div class="flex space-x-2">
                    <button id="start-button" class="flex-1 flex items-center justify-center px-4 py-2 border border-transparent text-base font-medium rounded-md shadow-sm text-white bg-cyan-600 hover:bg-cyan-700 disabled:bg-gray-500 disabled:cursor-not-allowed">Start</button>
                    <button id="pause-button" class="flex-1 flex items-center justify-center px-4 py-2 border border-transparent text-base font-medium rounded-md shadow-sm text-white bg-yellow-500 hover:bg-yellow-600 disabled:bg-gray-500 disabled:cursor-not-allowed">Pause</button>
                    <button id="reset-button" class="flex-1 flex items-center justify-center px-4 py-2 border border-transparent text-base font-medium rounded-md shadow-sm text-white bg-red-600 hover:bg-red-700">Reset</button>
                </div>
            </div>
        </aside>

    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- DOM Elements ---
    const edgesInput = document.getElementById('edges-input');
    const startNodeInput = document.getElementById('start-node-input');
    const targetNodeInput = document.getElementById('target-node-input');
    const previewButton = document.getElementById('preview-button');
    const startButton = document.getElementById('start-button');
    const pauseButton = document.getElementById('pause-button');
    const resetButton = document.getElementById('reset-button');
    const speedSlider = document.getElementById('speed-slider');
    const errorMessage = document.getElementById('error-message');
    
    const infoPlaceholder = document.getElementById('info-placeholder');
    const infoPanel = document.getElementById('info-panel');
    
    const bsRangeEl = document.getElementById('bs-range');
    const bsMidEl = document.getElementById('bs-mid');
    const bsCanpassEl = document.getElementById('bs-canpass');
    const bfsStatusHeaderEl = document.getElementById('bfs-status-header');
    const bfsCurrentNodeEl = document.getElementById('bfs-current-node');
    const bfsQueueEl = document.getElementById('bfs-queue');
    const bestMinWeightEl = document.getElementById('best-min-weight');
    const bestPathEl = document.getElementById('best-path');
    const logMessageEl = document.getElementById('log-message');

    const visContainer = document.getElementById('vis-container');
    const visCanvas = document.getElementById('vis-canvas');
    const placeholderText = document.getElementById('placeholder-text');
    const svg = d3.select(visCanvas);

    // --- State ---
    let graphData = null;
    let stepState = null;
    let isRunning = false;
    let isPaused = false;
    let visualizationSpeed = 500;
    let algorithmRunner = null;
    let runnerTimeout = null;
    let simulation = null;

    const defaultEdges = `1 2 20
1 3 15
1 4 10
2 3 8
2 5 12
3 4 5
3 5 10
4 5 7`;
    edgesInput.value = defaultEdges;
    
    const initialSimulationState = {
        phase: 'idle',
        logMessage: 'Setup graph and press Start.',
        L: 0, R: 0, mid: 0,
        canPass: undefined,
        currentNode: null, queue: [], markedNodes: new Set(), parentMap: new Map(), processedNodes: new Set(),
        consideringEdge: null, isVisitingMarked: false, prunedByWeight: false,
        bestPath: [], bestMinWeight: -1, pathForMid: [],
    };

    // --- Core Functions ---
    function parseGraphData() {
        errorMessage.textContent = '';
        try {
            const lines = edgesInput.value.split('\n').filter(line => line.trim() !== '');
            if (lines.length === 0) throw new Error("Edge data is empty.");

            const allNodeIds = new Set();
            const edges = lines.map((line, i) => {
                const parts = line.split(' ').map(Number);
                if (parts.length !== 3 || parts.some(isNaN)) {
                    throw new Error(`Invalid edge format on line ${i + 1}: "${line}"`);
                }
                const [u, v, w] = parts;
                 if (u <= 0 || v <= 0 || w <= 0) {
                     throw new Error(`Invalid edge data on line ${i + 1}: nodes and weights must be positive.`);
                }
                allNodeIds.add(u);
                allNodeIds.add(v);
                return { source: u, target: v, weight: w };
            });

            if (allNodeIds.size === 0) throw new Error("No valid nodes found.");
            
            const n = Math.max(...allNodeIds);
            const nodes = Array.from({ length: n }, (_, i) => ({ id: i + 1 }));

            const startNode = parseInt(startNodeInput.value, 10);
            const targetNode = parseInt(targetNodeInput.value, 10);

            if (isNaN(startNode) || isNaN(targetNode) || !allNodeIds.has(startNode) || !allNodeIds.has(targetNode)) {
                 throw new Error("Start or Target node is not in the graph.");
            }
            
            graphData = { nodes, edges };
            stepState = null;
            placeholderText.classList.add('hidden-panel');
            return true;
        } catch (e) {
            errorMessage.textContent = e.message;
            graphData = null;
            return false;
        }
    }

    function* widestPathAlgorithm(graph, startNode, targetNode) {
        const adj = new Map();
        let maxWeight = 0;
        for (const edge of graph.edges) {
            if (!adj.has(edge.source)) adj.set(edge.source, []);
            if (!adj.has(edge.target)) adj.set(edge.target, []);
            adj.get(edge.source).push({ v: edge.target, w: edge.weight });
            adj.get(edge.target).push({ v: edge.source, w: edge.weight });
            maxWeight = Math.max(maxWeight, edge.weight);
        }

        let L = 0;
        let R = maxWeight + 1;
        let bestState = { ...initialSimulationState };

        while (R - L > 1) {
            const mid = Math.floor((L + R) / 2);
            
            yield { ...bestState, phase: 'binary-search', L, R, mid, canPass: undefined, logMessage: `Testing threshold (mid): ${mid}` };
            
            const queue = [startNode];
            const marked = new Set([startNode]);
            const parentMap = new Map();
            const processedNodes = new Set();
            let pathFound = false;
            
            bestState.currentNode = null;
            bestState.queue = [];
            bestState.markedNodes = new Set();
            bestState.parentMap = new Map();
            bestState.processedNodes = new Set();

            bfs_loop: while (queue.length > 0) {
                const u = queue.shift();
                
                yield { ...bestState, phase: 'bfs-running', L, R, mid, currentNode: u, queue: [...queue], markedNodes: new Set(marked), parentMap: new Map(parentMap), processedNodes: new Set(processedNodes), logMessage: `BFS: Dequeued node ${u}.`};

                const neighbors = adj.get(u) || [];
                for (const { v, w } of neighbors) {
                    yield { ...bestState, phase: 'bfs-running', L, R, mid, currentNode: u, queue: [...queue], markedNodes: new Set(marked), consideringEdge: { source: u, target: v }, parentMap: new Map(parentMap), processedNodes: new Set(processedNodes), logMessage: `BFS: Considering edge ${u} -> ${v} (w=${w})` };

                    if (w < mid) {
                        yield { ...bestState, phase: 'bfs-running', L, R, mid, currentNode: u, queue: [...queue], markedNodes: new Set(marked), consideringEdge: { source: u, target: v }, prunedByWeight: true, parentMap: new Map(parentMap), processedNodes: new Set(processedNodes), logMessage: `Edge ${u} -> ${v} ignored. Weight ${w} < threshold ${mid}.` };
                        continue;
                    }
                    if (marked.has(v)) {
                        yield { ...bestState, phase: 'bfs-running', L, R, mid, currentNode: u, queue: [...queue], markedNodes: new Set(marked), consideringEdge: { source: u, target: v }, isVisitingMarked: true, parentMap: new Map(parentMap), processedNodes: new Set(processedNodes), logMessage: `Node ${v} already visited. Skipping.` };
                        yield { ...bestState, phase: 'bfs-running', L, R, mid, currentNode: u, queue: [...queue], markedNodes: new Set(marked), consideringEdge: { source: u, target: v }, isVisitingMarked: false, parentMap: new Map(parentMap), processedNodes: new Set(processedNodes), logMessage: `Node ${v} already visited. Skipping.` };
                        continue;
                    }

                    marked.add(v);
                    parentMap.set(v, u);
                    queue.push(v);
                    
                    yield { ...bestState, phase: 'bfs-running', L, R, mid, currentNode: u, queue: [...queue], markedNodes: new Set(marked), consideringEdge: { source: u, target: v }, parentMap: new Map(parentMap), processedNodes: new Set(processedNodes), logMessage: `BFS: Enqueued node ${v}.` };

                    if (v === targetNode) {
                        pathFound = true;
                        break bfs_loop;
                    }
                }
                processedNodes.add(u);
                yield { ...bestState, phase: 'bfs-running', L, R, mid, currentNode: u, queue: [...queue], markedNodes: new Set(marked), parentMap: new Map(parentMap), processedNodes: new Set(processedNodes), logMessage: `BFS: Finished exploring neighbors of ${u}.` };

            }
            
            const pathForMid = [];
            if (pathFound) {
                let curr = targetNode;
                while (curr !== undefined) {
                    pathForMid.push(curr);
                    if (curr === startNode) break;
                    curr = parentMap.get(curr);
                }
                pathForMid.reverse();
            }

            if (pathFound) {
                L = mid;
                bestState = { ...bestState, bestPath: pathForMid, bestMinWeight: L };
                yield { ...bestState, phase: 'bfs-result', L, R, mid, canPass: true, pathForMid, logMessage: `Path found for threshold ${mid}. Updating L = ${mid}.` };
            } else {
                R = mid;
                yield { ...bestState, phase: 'bfs-result', L, R, mid, canPass: false, pathForMid: [], logMessage: `No path for threshold ${mid}. Updating R = ${mid}.` };
            }
        }
        yield { ...bestState, phase: 'finished', L, R, mid: L, logMessage: `Algorithm finished. Best min-weight: ${L}.` };
    }


    // --- Visualization ---
    function updateVisualization(state) {
        if (!graphData || !state) return;

        const { phase, mid, markedNodes, currentNode, bestPath, pathForMid, prunedByWeight, isVisitingMarked, consideringEdge, parentMap, processedNodes } = state;
        const duration = 200;

        const pathEdges = new Set();
        const getEdgeId = (u, v) => `${Math.min(u,v)}-${Math.max(u,v)}`;
        
        let pathForColoring = [];
        if (phase === 'finished') pathForColoring = bestPath;
        else if (phase === 'bfs-result' && state.canPass) pathForColoring = pathForMid;
        
        for (let i = 0; i < pathForColoring.length - 1; i++) {
            pathEdges.add(getEdgeId(pathForColoring[i], pathForColoring[i+1]));
        }

        svg.selectAll("line.link")
            .transition().duration(duration)
            .attr("stroke-opacity", d => (d.weight < mid && phase.startsWith('bfs')) ? 0.1 : 0.7)
            .attr("stroke", d => {
                const edgeId = getEdgeId(d.source.id, d.target.id);
                const isConsidering = consideringEdge && edgeId === getEdgeId(consideringEdge.source, consideringEdge.target);
                const isTreeEdge = parentMap && ((parentMap.get(d.target.id) === d.source.id) || (parentMap.get(d.source.id) === d.target.id));

                if (isConsidering && isVisitingMarked) return "#a855f7"; // purple
                if (phase === 'finished' && pathEdges.has(edgeId)) return "#4ade80"; // bright green
                if (phase === 'bfs-result' && state.canPass && pathEdges.has(edgeId)) return "#22c55e"; // green
                if (phase === 'bfs-running' && isTreeEdge) return "#f97316"; // orange
                return "#999";
            });

        svg.selectAll("circle.node")
            .transition().duration(duration)
            .attr("fill", d => {
                if (phase === 'finished' && bestPath.includes(d.id)) return "#4ade80"; // bright green
                if (phase === 'bfs-result' && state.canPass && pathForMid.includes(d.id)) return "#22c55e"; // green
                if (d.id === currentNode) return "#ef4444"; // red
                if (phase.startsWith('bfs') && processedNodes && processedNodes.has(d.id)) return "#f97316"; // orange
                if (phase.startsWith('bfs') && markedNodes && markedNodes.has(d.id)) return "#facc15"; // yellow
                return "#475569";
            })
            .attr("r", d => (pathForColoring.includes(d.id) || (markedNodes && markedNodes.has(d.id))) ? 25 : 20);
        
        const prunedEdgeData = [];
        if (prunedByWeight && consideringEdge) {
            const allEdges = svg.selectAll("line.link").data(); 
            const foundEdge = allEdges.find(d => getEdgeId(d.source.id, d.target.id) === getEdgeId(consideringEdge.source, consideringEdge.target));
            if (foundEdge) prunedEdgeData.push(foundEdge);
        }
        
        svg.selectAll(".prune-mark").remove();
        if (prunedEdgeData.length > 0) {
            svg.append("g").selectAll("text")
                .data(prunedEdgeData)
                .join("text")
                .attr("class", "prune-mark")
                .attr("fill", "#ef4444")
                .attr("font-size", "24px")
                .attr("font-weight", "bold")
                .attr("text-anchor", "middle")
                .attr("dy", ".35em")
                .text("✖")
                .attr("x", d => (d.source.x + d.target.x) / 2)
                .attr("y", d => (d.source.y + d.target.y) / 2);
        }
    }
    
    function initializeVisualization() {
        if (!graphData) return;
        svg.html('');
        
        const width = visContainer.offsetWidth;
        const height = visContainer.offsetHeight;
        visCanvas.setAttribute('width', width);
        visCanvas.setAttribute('height', height);

        const nodes = JSON.parse(JSON.stringify(graphData.nodes));
        const edges = JSON.parse(JSON.stringify(graphData.edges));

        if (simulation) simulation.stop();

        simulation = d3.forceSimulation(nodes)
          .force("link", d3.forceLink(edges).id(d => d.id).distance(150))
          .force("charge", d3.forceManyBody().strength(-500))
          .force("center", d3.forceCenter(width / 2, height / 2));

        const link = svg.append("g").selectAll("line").data(edges).join("line")
          .attr("class", "link")
          .attr("stroke", "#999").attr("stroke-opacity", 0.6)
          .attr("stroke-width", d => Math.max(2, Math.sqrt(d.weight / 2)));

        const edgeLabels = svg.append("g").selectAll("text").data(edges).join("text")
          .attr("class", "text-xs fill-current text-gray-400")
          .text(d => d.weight);

        const node = svg.append("g").selectAll("circle").data(nodes).join("circle")
          .attr("class", "node")
          .attr("r", 20).attr("fill", "#475569")
          .attr("stroke", "#fff").attr("stroke-width", 1.5)
          .call(drag(simulation));

        const nodeLabels = svg.append("g").selectAll("text").data(nodes).join("text")
          .attr("class", "text-sm fill-current text-white font-bold")
          .attr("text-anchor", "middle").attr("dy", ".35em")
          .text(d => d.id);

        simulation.on("tick", () => {
          link.attr("x1", d => d.source.x).attr("y1", d => d.source.y)
              .attr("x2", d => d.target.x).attr("y2", d => d.target.y);
          edgeLabels.attr("x", d => (d.source.x + d.target.x) / 2)
                    .attr("y", d => (d.source.y + d.target.y) / 2);
          node.attr("cx", d => d.x).attr("cy", d => d.y);
          nodeLabels.attr("x", d => d.x).attr("y", d => d.y);
        });
    }

    function drag(simulation) {
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x; d.fy = d.y;
        }
        function dragged(event, d) {
            d.fx = event.x; d.fy = event.y;
        }
        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null; d.fy = null;
        }
        return d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended);
    }

    // --- UI Update & Control Flow ---
    function updateInfoPanel(state) {
        if (!state) state = initialSimulationState;

        bsRangeEl.textContent = `[${state.L}, ${state.R})`;
        bsMidEl.textContent = state.mid;

        bsCanpassEl.textContent = state.canPass === undefined ? 'Testing...' : state.canPass ? '✅ True' : '❌ False';
        bsCanpassEl.className = 'font-mono px-2 py-1 rounded';
        if (state.canPass === undefined) bsCanpassEl.classList.add('bg-gray-700');
        else if (state.canPass) bsCanpassEl.classList.add('bg-green-500/20', 'text-green-300');
        else bsCanpassEl.classList.add('bg-red-500/20', 'text-red-300');
        
        bfsStatusHeaderEl.textContent = `BFS Status (for mid=${state.mid})`;
        bfsCurrentNodeEl.textContent = state.currentNode ?? 'N/A';
        bfsQueueEl.textContent = state.queue ? '[' + state.queue.join(', ') + ']' : '[]';

        bestMinWeightEl.textContent = state.bestMinWeight > -1 ? state.bestMinWeight : 'N/A';
        bestPathEl.textContent = state.bestPath.join(' → ') || '[]';
        logMessageEl.textContent = state.logMessage;

        logMessageEl.className = 'font-mono p-2 rounded mt-1 text-white text-xs';
        if (state.phase === 'bfs-running') {
            if (state.prunedByWeight) logMessageEl.classList.add('bg-red-600/40');
            else if (state.isVisitingMarked) logMessageEl.classList.add('bg-purple-600/40');
            else logMessageEl.classList.add('bg-gray-700');
        } else if (state.phase === 'bfs-result') {
            logMessageEl.classList.add(state.canPass ? 'bg-green-500/30' : 'bg-red-500/30');
        } else {
             logMessageEl.classList.add('bg-gray-700');
        }
    }
    
    function setRunningState(running, paused = false) {
        isRunning = running;
        isPaused = paused;
        startButton.disabled = running;
        pauseButton.disabled = !running || stepState?.phase === 'finished';
        edgesInput.disabled = running;
        startNodeInput.disabled = running;
        targetNodeInput.disabled = running;

        if (running || stepState?.phase === 'finished') {
            infoPlaceholder.classList.add('hidden-panel');
            infoPanel.classList.add('flex');
            infoPanel.classList.remove('hidden-panel');
        } else {
            infoPlaceholder.classList.remove('hidden-panel');
            infoPanel.classList.remove('flex');
            infoPanel.classList.add('hidden-panel');
        }
        pauseButton.textContent = paused ? 'Resume' : 'Pause';
    }

    async function runStep() {
        if (!algorithmRunner || isPaused) return;

        const { value, done } = algorithmRunner.next();
        stepState = value;
        
        if(value) {
             updateInfoPanel(value);
             updateVisualization(value);
        }

        if (done || value?.phase === 'finished') {
            setRunningState(false);
            if (runnerTimeout) clearTimeout(runnerTimeout);
            updateInfoPanel(stepState); 
            updateVisualization(stepState);
            startButton.disabled = false;
            return;
        }
        
        runnerTimeout = setTimeout(runStep, visualizationSpeed);
    }
    
    // --- Event Handlers ---
    function handleStart() {
        if (isRunning) return;

        if (!graphData || stepState?.phase === 'finished') {
            if (!parseGraphData()) return;
        }

        if (stepState?.phase === 'finished') {
            stepState = null;
        }
        clearTimeout(runnerTimeout);

        if (!simulation) {
            initializeVisualization();
        }

        const startNode = parseInt(startNodeInput.value);
        const targetNode = parseInt(targetNodeInput.value);
        algorithmRunner = widestPathAlgorithm(graphData, startNode, targetNode);
        
        setRunningState(true, false);
        runStep();
    }
    
    function handlePauseToggle() {
        if (!isRunning) return;
        const newPausedState = !isPaused;
        setRunningState(true, newPausedState);
        if (!newPausedState) {
            setTimeout(runStep, 100);
        }
    }

    function handleReset() {
        if (runnerTimeout) clearTimeout(runnerTimeout);
        if (simulation) {
            simulation.stop();
            simulation = null;
        }
        
        stepState = null;
        graphData = null;
        algorithmRunner = null;
        svg.html('');
        placeholderText.classList.remove('hidden-panel');
        setRunningState(false);
        updateInfoPanel(null);
    }

    // --- Initial Setup & Listeners ---
    previewButton.addEventListener('click', () => {
        handleReset();
        if (parseGraphData()) {
            initializeVisualization();
        }
    });
    startButton.addEventListener('click', handleStart);
    pauseButton.addEventListener('click', handlePauseToggle);
    resetButton.addEventListener('click', handleReset);
    speedSlider.addEventListener('input', (e) => {
        visualizationSpeed = 2050 - parseInt(e.target.value);
    });

    const resizeObserver = new ResizeObserver(entries => {
        if (!entries.length) return;
        if(graphData) {
            initializeVisualization();
            if(stepState) {
                updateVisualization(stepState);
            }
        }
    });
    resizeObserver.observe(visContainer);

    visualizationSpeed = 2050 - parseInt(speedSlider.value);
    setRunningState(false);
});
</script>
</body>
</html>
